// 23.6 실행 컨텍스트 생성과 식별자 검색 과정
function example() {
  // 실행 컨텍스트는 소스코드를 실행하기 위한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역이다.

  // 전역 객체(브라우저 - window, node개발환경 - global)도 Object.prototype을 상속받는다.
  // 즉, 전역 객체도 프로토타입 체인의 일원이다.

  // 1️⃣ 전역 코드 평가의 순서는 다음과 같다.
  //    1. 실행 컨텍스트 생성 및 실행컨텍스트 스택(콜스택)에 푸쉬
  //    2. 렉시컬 환경(환경 레코드, 외부 렉시컬 환경에 대한 참조)생성 
  //    3. 환경 레코드 생성
  //       * var로 선언한 전역 변수, 함수 선언문으로 정의된 전역 함수는 
  //         객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
  //       * es6의 let,const로 선언한 전역 변수는 선언적 환경 레코드(코드블록)에 존재하게 된다.
  //    4. 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.
  //    5. 전역 코드의 외부 렉시컬 환경에 대한 참조는 null이다. 이는 전역 렉시컬 환경이 스코프 체인의 종점에 있다는 것을 의미한다.
  // 8️⃣ 전역 코드가 실행종료된다. 즉, 전역 실행 컨텍스트가 콜스택에서 팝되어 제거되고, 콜스택엔 아무것도 남지 않게된다.

  // 전역변수
  // 변수 호이스팅이 발생하고, 선언전에 undefined가 할당된다.
  // console.log(x);
  var x = 1;

  // var로 선언한 변수에 할당한 함수 표현식(아래와 같이 생김)도 동일하게 동작한다.
  // console.log(f);
  var f = function () { };

  // let, const로 선언한 변수는 선언전에 참조하려고 하면 ref에러가 난다.
  // console.log(y); // ReferenceError: Cannot access 'z' before initialization
  const y = 2;
  let z = 3;

  // 2️⃣ 전역함수 foo의 코드 평가 순서는 아래와 같다.
  //    1. 함수 실행 컨텍스트 생성
  //    2. 렉시컬 환경(환경 레코드, 외부 렉시컬 환경에 대한 참조)생성 실행 컨텍스트 스택에 푸쉬
  //    3. 환경 레코드 생성
  //    4. 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다.
  //    5. 함수는 [[Environment]]내부슬롯으로 자신이 정의된 스코프(즉, 상위 스코프)를 기억한다. 따라서 상위 스코프의 실행 컨택스트(즉, 전역 실행 컨텍스트)가 곧 외부 렉시컬 환경에 대한 참조가 된다.
  function foo(a) { // 함수 선언문은 위와 다르게 전역 객체에 식별자가 바인딩(선언)되고, 생성된 함수를 즉시 할당한다.
    // 3️⃣ foo함수 실행(런타임)이 일어나서 
    // 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하고, 값을 바인딩한다.
    var x = 3;
    const y = 4;

    // 4️⃣ bar함수 코드 평가
    // 1. 함수 실행 컨텍스트 생성
    // 2. 렉시컬 환경생성 후 함수 실행 컨텍스트를 콜스택에 푸쉬
    // ... 
    function bar(b) {
      // 5️⃣ bar함수 실행(런타임)이 일어나서
      // ...
      const z = 5;
      // 6️⃣ 아래 코드가 실행되는 순서는 아래와 같다.
      //    1. 평가/ 먼저 console식별자 검색을 스코프 체이닝을 통해서 시작한다. 
      //       스코프체인의 종점 전역 렉시컬 환경으로 이동해서 
      //       객체 환경 레코드의 BindingObject를 통해 전역 객체에서 console식별자를 찾을 수 있다.
      //    2. 평가/ console에 바인딩된 객체, log메서드를 프로토타입 체이닝 통해 검색한다.
      //       이때 log는 상속된게 아니라, console객체가 직접 소유하는 프로퍼티이다.
      console.log(`console.hasOwnProperty('log'): ${console.hasOwnProperty('log')}`);
      //    3. 평가/ console.log메서드에 전달할 인수(a+b+x+y+z)를 평가하기 위해 각 식별자를 스코프체이닝을 통해 검색한다.
      //       실행/ console.log메서드를 호출한다.
      console.log(a + b + x + y + z);
    }
    // 7️⃣ bar함수가 실행종료된다. 즉, bar함수 실행 컨텍스트가 콜스택에서 팝되어 제거된다.
    //   하지만 bar함수의 렉시컬환경에 대한 참조가 아직 남아있다면 메모리에서 바로 삭제되지 않는다.
    bar(10);
  }

  // 8️⃣ foo함수가 실행종료된다. 즉, foo함수 실행 컨텍스트가 콜스택에서 팝되어 제거된다.
  foo(20); // 따라서 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.

  // 그렇다면 실행 컨텍스트의 관점에서 블록 레벨 스코프는 어떨까?
  // 아래 코드에서 for문의 코드 블록이 실행되면 블록 레벨 스코프를 생성해야한다.
  // 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 생성해서 기존 전역 렉시컬 환경을 교체한다.
  // 그리고 let을 사용하기 때문에 코드 블록이 실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다.

  // Q. 렉시컬 환경 이전에 실행 컨텍스트는 단 한번만 생성되는 건지?
  // 이전에 사용했던값, 실제 사용한 값은 스택에서 빠졌는데 함수에서 참조해놓은 값을 저장해놓은게 렉시컬 환경
  // for문은 블록 단위에서 끝난다.

  // A. 재귀함수는 자기자신 함수를 계속 호출하는 것 팩토리얼로 예를 들자면, 1,2,3,... 함수를 하나씩 호출하면서 스택에 쌓이고,
  // for문은 내부 변수만 바뀔거니까 스택안에서 지역변수 하나면 바뀌는거고, 재귀는 지역변수 뿐만아니라 함수도 저장되야함
  let count = 0;
  const arr = [1, 2, 3, 4];

  for (let i = 0; i < arr.length; i++) {
    count = count + i;
  }

  console.log(count);
}

test("run", () => {
  expect(example()).toBe();
});
